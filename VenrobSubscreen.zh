#option SHORT_CIRCUIT on
#option BINARY_32BIT off
#option HEADER_GUARD on
#include "std.zh"
#include "std_zh/dmapgrid.zh"
#include "Time.zh"

/*
DEV NOTES

PANELS: Multiple separate screens, as many games such as OoT/MM have.
	-EVERY module needs a panel value, indicating which panel it belongs to.
	-ANIMATION:
		-3D Cube style animations between panels, as well as an instant switch, and a 2d slide effect. This will be in the panel settings.
SETTINGS: Global options for an entire subscreen.
	-Stored in a settings module, which is always the first module (module '0')
*/

namespace Venrob
{
	typedef const int DEFINE;
	typedef const int CONFIG;
	typedef const bool CONFIGB;
}

namespace Venrob::Subscreen
{
	//start Constants/vars
	DEFINE MAX_MODULE_SIZE = 32;
	DEFINE MODULE_BUF_SIZE = 200;
	DEFINE MODULE_META_SIZE = P1;
	DEFINE SUBSCR_STORAGE_SIZE = MAX_INT;
	DEFINE MAX_MODULES = ((SUBSCR_STORAGE_SIZE / MAX_MODULE_SIZE)/10000)*10000;
	DEFINE NUM_SETTINGS = 100;
	DEFINE SZ_SETTINGS = NUM_SETTINGS + MODULE_META_SIZE;
	
	
	DEFINE MAX_TILE = 214499;
	DEFINE NUM_TILES = MAX_TILE+1;
	
	untyped activeData[SUBSCR_STORAGE_SIZE];
	int activeModules[MAX_MODULES];
	untyped passiveData[SUBSCR_STORAGE_SIZE];
	int passiveModules[MAX_MODULES];
	untyped g_arr[G_ARR_SIZE];
	untyped btn_data[BTNDAT_SZ];
	CONFIGB DEBUG = true;
	enum Data //start Settings
	{
		START_SETTINGS_META,
		START_SETTINGS = START_SETTINGS_META + P1,
		STTNG_FLAGS1 = START_SETTINGS,
		STTNG_FLAGS2,
		STTNG_FLAGS3,
		STTNG_FLAGS4,
		A_STTNG_FRAME_HOLD_DELAY,
		A_STTNG_SELECTOR_TYPE,
		A_STTNG_SELECTOR_VALUE,
		A_STTNG_SELECTOR_VALUE2,
		A_STTNG_SELECTOR_SFX,
		A_STTNG_BUTTON_ITEM_ENABLED_BITS,
		A_STTNG_BUTTON_ITEM_ASSIGNABLE_BITS,
		END_SETTINGS = START_SETTINGS+NUM_SETTINGS
	}; //end Settings
	enum SelectorType //start
	{
		SEL_RECTANGLE, //Value is Color. Value2 unused.
		SEL_TILE, //Value is Tile, Value2 is CSet
		SEL_COMBO, //Value is Tile, Value2 is CSet
		SEL_ITEM //Value is Item ID, Value2 is unused.
	}; //end
	
	enum GArr //start
	{
		IS_INITIALIZED,
		INPUT_TIMERS,
		NUM_ACTIVE_MODULES = INPUT_TIMERS+18,
		SZ_ACTIVE_DATA,
		NUM_PASSIVE_MODULES,
		SZ_PASSIVE_DATA,
		ACTIVE_TIMER,
		PASSIVE_TIMER,
		ACTIVE_SELECTED_INDEX,
		LAST_SELECTED_INDEX,
		INDEX_SELECTION_COOLDOWN,
		ACTIVE_BITMAP,
		PASSIVE_BITMAP,
		MINITILE_BITMAP,
		ACTIVE_1FRAME_FLAGS_1,
		PASSIVE_1FRAME_FLAGS_1,
		SHARED_1FRAME_FLAGS_1,
		PREPARED_SELECTOR_DATA_START,
		PREPARED_SELECTOR_DATA_END = PREPARED_SELECTOR_DATA_START + 10,
		G_ARR_SIZE
	}; //end
	enum BTN //start
	{
		BTNITMS,
		BTNITM_A = BTNITMS+CB_A,
		BTNITM_B = BTNITMS+CB_B,
		BTNITM_L = BTNITMS+CB_L,
		BTNITM_R = BTNITMS+CB_R,
		BTNITM_EX1 = BTNITMS+CB_EX1,
		BTNITM_EX2 = BTNITMS+CB_EX2,
		BTNITM_EX3 = BTNITMS+CB_EX3,
		BTNITM_EX4 = BTNITMS+CB_EX4,
		BTNPOS = CB_MAX,
		BTNPOS_A = BTNPOS+CB_A,
		BTNPOS_B = BTNPOS+CB_B,
		BTNPOS_L = BTNPOS+CB_L,
		BTNPOS_R = BTNPOS+CB_R,
		BTNPOS_EX1 = BTNPOS+CB_EX1,
		BTNPOS_EX2 = BTNPOS+CB_EX2,
		BTNPOS_EX3 = BTNPOS+CB_EX3,
		BTNPOS_EX4 = BTNPOS+CB_EX4,
		BTNDAT_SZ = CB_MAX*2
	}; //end
	
	//end Constants/vars
	
	//start Module enums
	enum //For parameters for modules.
	{
		//Meta
		M_SIZE, M_META_SIZE, M_TYPE, M_VER, M_PANEL, M_LAYER, M_X, M_Y, M_FLAGS1,
		//Parameters
		P1, P2, P3, P4, P5, P6, P7, P8, P9, P10
	};

	DEFINE SUBSCR_BITS_INT = 18;
	enum //start Flag Bits
	{
		FLAG1  = 000000000000000001b,
		FLAG2  = 000000000000000010b,
		FLAG3  = 000000000000000100b,
		FLAG4  = 000000000000001000b,
		FLAG5  = 000000000000010000b,
		FLAG6  = 000000000000100000b,
		FLAG7  = 000000000001000000b,
		FLAG8  = 000000000010000000b,
		FLAG9  = 000000000100000000b,
		FLAG10 = 000000001000000000b,
		FLAG11 = 000000010000000000b,
		FLAG12 = 000000100000000000b,
		FLAG13 = 000001000000000000b,
		FLAG14 = 000010000000000000b,
		FLAG15 = 000100000000000000b,
		FLAG16 = 001000000000000000b,
		FLAG17 = 010000000000000000b,
		FLAG18 = 100000000000000000b
	}; //end Flag Bits
	//start Flags
	enum //SelectableItems
	{
		FLAG_SELIT_ABTN = FLAG1,
		FLAG_SELIT_BBTN = FLAG2
	};
	enum //Minimap
	{
		FLAG_MMP_COMP_ON_BOSS = FLAG1, //instead of triforce
		FLAG_MMP_SHOW_EXPLORED_ROOMS_OW = FLAG2,
		FLAG_MMP_SHOW_EXPLORED_ROOMS_DUNGEON = FLAG3,
		FLAG_MMP_SHOW_EXPLORED_ROOMS_INTERIOR = FLAG4,
		FLAG_MMP_COMPASS_BLINK_DOESNT_STOP = FLAG5,
		FLAG_MMP_IGNORE_DMAP_BGTILE = FLAG6,
		FLAG_MMP_LARGE_PLAYER_COMPASS_MARKERS = FLAG7
	};
	enum //Heart Row
	{
		FLAG_HROW_RTOL = FLAG1
	};
	enum //Magic Row
	{
		FLAG_MROW_RTOL = FLAG1
	};
	enum //Magic Row
	{
		FLAG_CRROW_RTOL = FLAG1
	};
	enum //Magic
	{
		FLAG_MAG_ISHALF = FLAG1
	};
	enum //A_STTNG_FLAGS1
	{
		FLAG_ASTTNG_ITEMS_USE_HITBOX_FOR_SELECTOR = FLAG1
	};
	enum //ACTIVE_1FRAME_FLAGS_1
	{
		FLAG_A1FR_DREW_SELECTOR = FLAG1
	};
	enum //Counter
	{
		MASK_CNTR_ALIGN = FLAG1 | FLAG2,
		FLAG_CNTR_SPECIAL = FLAG3,
		//FLAG4 no longer used
		FLAG_CNTR_SPACE_INSTEAD_LEAD_ZERO = FLAG5
	};
	enum //Special Counter Types
	{
		CNTR_ANYKEY,
		CNTR_LKEY,
		CNTR_ABTN,
		CNTR_BBTN,
		CNTR_MAX_SPECIAL
	};
	enum //Minitile
	{
		MASK_MINITL_CRN = FLAG1 | FLAG2
	};
	enum //ItemName
	{
		MASK_ITEMNM_ALIGN = FLAG1 | FLAG2
	};
	//end Flags
	enum moduleType //start
	{
		MODULE_TYPE_SETTINGS = -1, //Internal use only; for settings
		MODULE_TYPE_NULL, //NULL
		MODULE_TYPE_BGCOLOR, //FORMAT: {META..., COLOR} - COLOR is an integer 0 to 255, representing a color from ZC's palette to use.
		MODULE_TYPE_SEL_ITEM_ID, //FORMAT: {META..., ITEMID, POS, UP, DOWN, LEFT, RIGHT}
		MODULE_TYPE_SEL_ITEM_CLASS, //FORMAT: {META..., ITEMCLASS, POS, UP, DOWN, LEFT, RIGHT}
		MODULE_TYPE_BUTTONITEM, //FORMAT: {META..., BUTTON}
		DEPR_MODULE_TYPE_BBUTTONITEM, //DEPRECATED - was format {META...}
		MODULE_TYPE_PASSIVESUBSCREEN, //FORMAT: {META...}
		MODULE_TYPE_MINIMAP, //FORMAT: {META..., POSCOLOR, EXPLCOLOR, UNEXPLCOLOR, COMPCOLOR, COMP_DEFEATEDCOLOR, BLINKRATE, 16x8TILE, 16x8CSET, 8x8TILE, 8x8CSET}
		MODULE_TYPE_TILEBLOCK, //FORMAT: {META..., TILE, CSET, WID, HEI}
		MODULE_TYPE_HEART, //FORMAT: {META..., TILE, CSET, CONTAINER_NUM}
		MODULE_TYPE_HEARTROW, //FORMAT: {META..., TILE, CSET, CONTAINER_NUM, COUNT, SPACING}
		MODULE_TYPE_COUNTER, //FORMAT: {META..., FONT, CNTR, INFITEM, INFCHAR, MINDIG, TXTCOL, BGCOL, SHADCOL, SHADOWTYPE}
		MODULE_TYPE_MINITILE, //FORMAT: {META..., TILE, CSET}
		MODULE_TYPE_NONSEL_ITEM_ID, //FORMAT: {META..., ITEMID}
		MODULE_TYPE_NONSEL_ITEM_CLASS, //FORMAT: {META..., ITEMCLASS}
		MODULE_TYPE_CLOCK, //FORMAT: {META..., FONT, TXTCOL, BGCOL, SHADCOL, SHADOWTYPE}
		MODULE_TYPE_ITEMNAME, //FORMAT: {META..., FONT, TXTCOL, BGCOL, SHADCOL, SHADOWTYPE, MAXWID, VSPACE}
		MODULE_TYPE_DMTITLE, //FORMAT: {META..., FONT, TXTCOL, BGCOL, SHADCOL, SHADOWTYPE}
		MODULE_TYPE_MAGIC, //FORMAT: {META..., TILE, CSET, CONTAINER_NUM}
		MODULE_TYPE_MAGICROW, //FORMAT: {META..., TILE, CSET, CONTAINER_NUM, COUNT, SPACING}
		MODULE_TYPE_CRPIECE, //FORMAT: {META..., TILE, CSET, CONTAINER_NUM, COUNTER, PER_CONT}
		MODULE_TYPE_CRROW, //FORMAT: {META..., TILE, CSET, CONTAINER_NUM, COUNTER, PER_CONT, COUNT, SPACING}
		/* TODO
		Complex Modules:
		LARGE MAP (Active only)
		COUNTER METER (%)
		TEXT (Will be a large module, to store the char data)
		TRIFORCE FRAME
		TRIFORCE PIECE

		Shapes:
		RECTANGLE
		TRIANGLE
		CIRCLE
		LINE
		*/
		MODULE_TYPE_MAX
	}; //end
	//end Module enums
	
	//start Clearing/Init
	void init()
	{
		clear();
		init_buttons();
	}
	
	void clear()
	{
		clearActive();
		clearPassive();
	}
	
	void clearActive()
	{
		memset(activeData, 0, SUBSCR_STORAGE_SIZE);
		memset(activeModules, 0, MAX_MODULES);
		g_arr[NUM_ACTIVE_MODULES] = 1;
		g_arr[SZ_ACTIVE_DATA] = SZ_SETTINGS;
		activeModules[1] = g_arr[SZ_ACTIVE_DATA];
		load_active_settings(NULL);
	}
	
	void clearPassive()
	{
		memset(passiveData, 0, SUBSCR_STORAGE_SIZE);
		memset(passiveModules, 0, MAX_MODULES);
		g_arr[NUM_PASSIVE_MODULES] = 1;
		g_arr[SZ_PASSIVE_DATA] = SZ_SETTINGS;
		passiveModules[1] = g_arr[SZ_PASSIVE_DATA];
		load_passive_settings(NULL);
	} //end Clearing/Init
	//start Settings
	void load_active_settings(untyped settings_arr) //start
	{
		untyped settings[MODULE_META_SIZE+NUM_SETTINGS];
		load_default_settings(settings, true);
		if(IsValidArray(settings_arr))
		{
			memcpy(settings, 0, settings_arr, 0, Min(NUM_SETTINGS, SizeOfArray(settings_arr)));
		}
		memcpy(activeData, START_SETTINGS, settings, START_SETTINGS, NUM_SETTINGS);
		activeData[M_SIZE] = SZ_SETTINGS;
		activeData[M_TYPE] = MODULE_TYPE_SETTINGS;
	} //end
	
	void load_passive_settings(untyped settings_arr) //start
	{
		untyped settings[MODULE_META_SIZE+NUM_SETTINGS];
		load_default_settings(settings, false);
		if(IsValidArray(settings_arr))
			memcpy(settings, 0, settings_arr, 0, Min(NUM_SETTINGS, SizeOfArray(settings_arr)-1));
		memcpy(passiveData, START_SETTINGS, settings, START_SETTINGS, NUM_SETTINGS);
		passiveData[M_SIZE] = SZ_SETTINGS;
		passiveData[M_TYPE] = MODULE_TYPE_SETTINGS;
	} //end

	void load_default_settings(untyped settings, bool active) //start
	{
		if(active)
		{
			settings[STTNG_FLAGS1] = 000000000000000000b;
			settings[STTNG_FLAGS2] = 000000000000000000b;
			settings[STTNG_FLAGS3] = 000000000000000000b;
			settings[STTNG_FLAGS4] = 000000000000000000b;
			settings[A_STTNG_FRAME_HOLD_DELAY] = 30;
			settings[A_STTNG_SELECTOR_TYPE] = SEL_RECTANGLE;
			settings[A_STTNG_SELECTOR_VALUE] = 0x01;
			settings[A_STTNG_SELECTOR_VALUE2] = 0;
			settings[A_STTNG_SELECTOR_SFX] = SFX_CURSOR;
			settings[A_STTNG_BUTTON_ITEM_ENABLED_BITS] = (1b<<CB_A) | (1b<<CB_B);
			settings[A_STTNG_BUTTON_ITEM_ASSIGNABLE_BITS] = (1b<<CB_B);
		}
		else
		{
			settings[STTNG_FLAGS1] = 000000000000000000b;
			settings[STTNG_FLAGS2] = 000000000000000000b;
			settings[STTNG_FLAGS3] = 000000000000000000b;
			settings[STTNG_FLAGS4] = 000000000000000000b;
		}
	} //end
	//end Settings
	
	//start Running
	void runActiveSubscreen()
	{
		/*for(int q = 0; q <= g_arr[NUM_ACTIVE_MODULES]; ++q)
		{
			Trace(activeModules[q]);
		}
		int iter = 0;
		for(int q = activeModules[0]; q < activeModules[g_arr[NUM_ACTIVE_MODULES]]; ++q)
		{
			bool isSz;
			for(int i = 0; i < g_arr[NUM_ACTIVE_MODULES]; ++i)
			{
				if(activeModules[i]==q) isSz = true;
			}
			if(isSz) TraceNL();
			printf("%d: %d\n", iter++, activeData[q]);
			//Trace(activeData[q]);
		}*/
		event_t event = EVENT_NONE;
		bitmap abit = getSubscreenBitmap(true), pbit = getSubscreenBitmap(false);
		do
		{
			runPassiveLogic();
			for(int q = 1; q < g_arr[NUM_ACTIVE_MODULES] ; ++q)
			{
				untyped buf[MODULE_BUF_SIZE];
				memcpy(buf, 0, activeData, activeModules[q], activeData[activeModules[q]]);
				if((g_arr[ACTIVE_SELECTED_INDEX]==-1) || (g_arr[ACTIVE_SELECTED_INDEX] == buf[P2] && isSelectable(buf[M_TYPE]) && !canSelect(buf)))
				{
					g_arr[ACTIVE_SELECTED_INDEX] = -1;
					for(int i = 1; i < g_arr[NUM_ACTIVE_MODULES]; ++i)
					{
						int indx = activeModules[i];
						if(canSelect(activeData, indx))
						{
							g_arr[ACTIVE_SELECTED_INDEX] = activeData[indx+P2];
							break;
						}
					}
				}
				event = runModule(q, buf, true);
			}
			if(g_arr[ACTIVE_SELECTED_INDEX] != g_arr[LAST_SELECTED_INDEX])
				clearPreparedSelector();
			else runPreparedSelector(true);
			activetimers();
			KillButtons();
			abit->Blit(7, RT_SCREEN, 0, 0, 256, 224, 0, -56, 256, 224, 0, 0, 0, 0, 0, true);
			clearActive1frame();
			handle_buttons();
			Waitframe();
			switch(event)
			{
				case EVENT_EXIT:
					Input->Press[CB_START] = true;
					break;
			}
		}
		until(Input->Press[CB_START]);
	}
	
	void activetimers()
	{
		++g_arr[ACTIVE_TIMER];
		g_arr[ACTIVE_TIMER] %= 100000000000000000b;
		for(int q = INPUT_TIMERS; q < INPUT_TIMERS+18; ++q)
		{
			++g_arr[q];
			if(activeData[A_STTNG_FRAME_HOLD_DELAY])
				g_arr[q]%=activeData[A_STTNG_FRAME_HOLD_DELAY];
		}
	}
	
	void runPassiveSubscreen()
	{
		runPassiveLogic();
		drawPassiveSubscreen();
		handle_buttons();
	}
	
	void runPassiveLogic()
	{
		++g_arr[PASSIVE_TIMER];
		g_arr[PASSIVE_TIMER] %= 100000000000000000b;
		for(int q = 1; q < g_arr[NUM_PASSIVE_MODULES] ; ++q)
		{
			untyped buf[MODULE_BUF_SIZE];
			memcpy(buf, 0, passiveData, passiveModules[q], passiveData[passiveModules[q]]);
			runModule(q, buf, false);
		}
	}
	
	void drawPassiveSubscreen()
	{
		getSubscreenBitmap(false)->Blit(7, RT_SCREEN, 0, 0, 256, 56, 0, -56, 256, 56, 0, 0, 0, 0, 0, true);
		runPreparedSelector(false);
		clearPassive1frame();
	}
	
	enum event_t
	{
		EVENT_EXIT = -1,
		EVENT_NONE,
		EVENT_MAX
	};
	
	event_t runModule(int mod_indx, untyped module_arr, bool active)
	{
		bitmap bit = getSubscreenBitmap(active);
		switch(module_arr[M_TYPE])
		{
			case MODULE_TYPE_BGCOLOR: //start
			{
				if(module_arr[P1])
				{
					if(active)
						bit->Rectangle(module_arr[M_LAYER], 0, 0, 256, 224, module_arr[P1], 1, 0, 0, 0, true, OP_OPAQUE);
					else
						bit->Rectangle(module_arr[M_LAYER], 0, 0, 256, 56, module_arr[P1], 1, 0, 0, 0, true, OP_OPAQUE);
				}
				break;
			} //end
			
			case MODULE_TYPE_BUTTONITEM: //start
			{
				int itid = get_btn_itm(module_arr[P1]);
				if(itid)
				{
					itemdata id = Game->LoadItemData(itid);
					unless(id->ASpeed) id->ASpeed = 1;
					unless(id->AFrames) id->AFrames = 1;
					int frm = 0;
					int temp = (g_arr[active ? ACTIVE_TIMER : PASSIVE_TIMER] % ((id->ASpeed * id->AFrames) + (id->ASpeed * id->Delay))) - (id->Delay * id->ASpeed);
					if(temp >= 0)
						frm = Floor(temp / id->ASpeed);
					bit->FastTile(module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y], id->Tile + frm, id->CSet, OP_OPAQUE);
				}
				break;
			} //end
			
			case MODULE_TYPE_NONSEL_ITEM_ID:
			case MODULE_TYPE_NONSEL_ITEM_CLASS:
			case MODULE_TYPE_SEL_ITEM_ID:
			case MODULE_TYPE_SEL_ITEM_CLASS: //start
			{
				bool nonsel = module_arr[M_TYPE] == MODULE_TYPE_NONSEL_ITEM_ID || module_arr[M_TYPE] == MODULE_TYPE_NONSEL_ITEM_CLASS;
				unless(active || nonsel) break; //Selectable not allowed on passive
				bool class = module_arr[M_TYPE]==MODULE_TYPE_SEL_ITEM_CLASS || module_arr[M_TYPE]==MODULE_TYPE_NONSEL_ITEM_CLASS;
				int itmid = (class?(get_item_of_class(module_arr[P1])):(module_arr[P1]));
				if(itmid < 0 || !hasItem(itmid)) break;
				
				itemdata id = Game->LoadItemData(itmid);
				unless(id->ASpeed) id->ASpeed = 1;
				unless(id->AFrames) id->AFrames = 1;
				int frm = 0;
				int temp = (g_arr[active ? ACTIVE_TIMER : PASSIVE_TIMER] % ((id->ASpeed * id->AFrames) + (id->ASpeed * id->Delay))) - (id->Delay * id->ASpeed);
				if(temp >= 0)
					frm = Floor(temp / id->ASpeed);
				bit->FastTile(module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y], id->Tile + frm, id->CSet, OP_OPAQUE);
				if(nonsel) break;
				if(g_arr[ACTIVE_SELECTED_INDEX] == module_arr[P2])
				{
					for(int q = 0; q < CB_MAX; ++q) //start
					{
						switch(q) //start Filter out unused buttons
						{
							case CB_A: case CB_B: case CB_L: case CB_R: case CB_EX1: case CB_EX2: case CB_EX3: case CB_EX4:
							{
								unless(activeData[A_STTNG_BUTTON_ITEM_ASSIGNABLE_BITS] & (1<<q))
									continue;
								if(!Game->FFRules[qr_NO_L_R_BUTTON_INVENTORY_SWAP] && (q == CB_L || q == CB_R))
									continue;
								if(Game->FFRules[qr_USE_EX1_EX2_INVENTORYSWAP] && (q == CB_EX3 || q == CB_EX4))
									continue;
								break;
							}
							default: continue;
						} //end
						if(btn_data[BTNPOS+q] != module_arr[P2] && Input->Press[q])
						{
							PressCheck(q);
							if(class)
							{
								equp_btn_itmclass(q, module_arr[P1]);
							}
							else
							{
								equp_btn_itm(q, module_arr[P1]);
							}
							set_btn_pos(q, module_arr[P2]);
						}
					} //end
					/*
					if(Hero->ItemA != itmid && PressCheck(CB_A) && Game->FFRules[qr_SELECTAWPN])
					{
						//Hero->SetItemSlot(itmid, 1, 1);
						Hero->ItemA = itmid;
						killBtn(CB_A, true);
						if(Hero->ItemB == itmid) Hero->SetItemSlot(0, 2, 2);
					}
					else if(Hero->ItemB != itmid && PressCheck(CB_B))
					{
						//Hero->SetItemSlot(itmid, 2, 1);
						Hero->ItemB = itmid;
						killBtn(CB_B, true);
						if(Hero->ItemA == itmid) Hero->SetItemSlot(0, 1, 2);
					}
					else */
					unless(g_arr[INDEX_SELECTION_COOLDOWN] || (g_arr[ACTIVE_SELECTED_INDEX] != g_arr[LAST_SELECTED_INDEX]))
					{
						int selectedDir = -1;
						for(int dir = DIR_UP; dir <= DIR_RIGHT; ++dir)
						{
							if(PressCheck(CB_UP+dir) && module_arr[P3+dir] > -1)
							{
								selectedDir = dir;
								break;
							}
						}
						if(selectedDir > -1)
						{
							bool visited[MAX_INT];
							visited[module_arr[P2]] = true;
							g_arr[ACTIVE_SELECTED_INDEX] = module_arr[P3+selectedDir];
							for(int q = 1; q < g_arr[NUM_ACTIVE_MODULES] ; ++q)
							{
								int indx = activeModules[q];
								if(isSelectable(activeData[indx+M_TYPE]) && g_arr[ACTIVE_SELECTED_INDEX] == activeData[indx+P2])
								{
									if(visited[activeData[indx+P2]])
									{
										g_arr[ACTIVE_SELECTED_INDEX] = module_arr[P2];
										break;
									}
									if(canSelect(activeData, indx))
										break;
									else
									{
										g_arr[ACTIVE_SELECTED_INDEX] = Max(-1, activeData[indx+P3+selectedDir]);
										q = 1;
									}
									visited[activeData[indx+P2]] = true;
								}
							}
							if(g_arr[ACTIVE_SELECTED_INDEX]==-1) g_arr[ACTIVE_SELECTED_INDEX] = module_arr[P2];
							if(g_arr[ACTIVE_SELECTED_INDEX]!=module_arr[P2]) //If the selection changed
							{
								KillButtons(true);
								Audio->PlaySound(activeData[A_STTNG_SELECTOR_SFX]);
								g_arr[INDEX_SELECTION_COOLDOWN] = 2;
								break;
							}
						}
					}
					bool hit = activeData[STTNG_FLAGS1]&FLAG_ASTTNG_ITEMS_USE_HITBOX_FOR_SELECTOR;
					unless(id->HitWidth) id->HitWidth = 16;
					unless(id->HitHeight) id->HitHeight = 16;
					unless(id->TileWidth) id->TileWidth = 1;
					unless(id->TileHeight) id->TileHeight = 1;
					DrawSelector(module_arr[M_LAYER], module_arr[M_X] + (hit ? id->HitXOffset : id->DrawXOffset), module_arr[M_Y] + (hit ? id->HitYOffset : id->DrawYOffset), (hit ? id->HitWidth : id->TileWidth*16), (hit ? id->HitHeight : id->TileHeight*16), true);
				}
				break;
			} //end
			
			case MODULE_TYPE_PASSIVESUBSCREEN: //start
			{
				bit->BlitTo(module_arr[M_LAYER], getSubscreenBitmap(false), 0, 0, 256, 56, module_arr[M_X], module_arr[M_Y], 256, 56, 0, 0, 0, 0, 0, true);
				break;
			} //end
			
			case MODULE_TYPE_MINIMAP: //start
			{
				minimap(module_arr,bit,active);
			} //end
			
			case MODULE_TYPE_TILEBLOCK: //start
			{
				bit->DrawTile(0,  module_arr[M_X], module_arr[M_Y], module_arr[P1], module_arr[P3], module_arr[P4], module_arr[P2], -1, -1, 0, 0, 0, FLIP_NONE, true, OP_OPAQUE);
				break;
			} //end
			
			
			case MODULE_TYPE_HEART: //start
			{
				heart(bit, module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y], module_arr[P3], module_arr[P1], module_arr[P2]);
				break;
			} //end
			
			case MODULE_TYPE_HEARTROW: //start
			{
				if(module_arr[M_FLAGS1] & FLAG_HROW_RTOL)
					invheartrow(bit, module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y], module_arr[P3], module_arr[P1], module_arr[P2], module_arr[P4], module_arr[P5]);
				else
					heartrow(bit, module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y], module_arr[P3], module_arr[P1], module_arr[P2], module_arr[P4], module_arr[P5]);
				break;
			} //end
			case MODULE_TYPE_MAGIC: //start
			{
				if(module_arr[M_FLAGS1] & FLAG_MAG_ISHALF)
					halfmagic(bit, module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y], module_arr[P1], module_arr[P2]);
				else
					magic(bit, module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y], module_arr[P3], module_arr[P1], module_arr[P2]);
				
				break;
			} //end
			
			case MODULE_TYPE_MAGICROW: //start
			{
				if(module_arr[M_FLAGS1] & FLAG_MROW_RTOL)
					invmagicrow(bit, module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y], module_arr[P3], module_arr[P1], module_arr[P2], module_arr[P4], module_arr[P5]);
				else
					magicrow(bit, module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y], module_arr[P3], module_arr[P1], module_arr[P2], module_arr[P4], module_arr[P5]);
				break;
			} //end
			
			case MODULE_TYPE_CRPIECE: //start
			{
				crpiece(bit, module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y], module_arr[P3], module_arr[P1], module_arr[P2], module_arr[P4], module_arr[P5]);
				break;
			} //end
			
			case MODULE_TYPE_CRROW: //start
			{
				if(module_arr[M_FLAGS1] & FLAG_CRROW_RTOL)
					invmiscrow(bit, module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y], module_arr[P3], module_arr[P1], module_arr[P2], module_arr[P6], module_arr[P7], module_arr[P4], module_arr[P5]);
				else
					miscrow(bit, module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y], module_arr[P3], module_arr[P1], module_arr[P2], module_arr[P6], module_arr[P7], module_arr[P4], module_arr[P5]);
				break;
			} //end
			
			case MODULE_TYPE_COUNTER: //start
			{
				counter(module_arr, bit, module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y]);
				break;
			} //end
			case MODULE_TYPE_MINITILE: //start
			{
				minitile(bit, module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y], module_arr[P1], module_arr[P2], module_arr[M_FLAGS1]&MASK_MINITL_CRN);
				break;
			} //end
			case MODULE_TYPE_CLOCK: //start
			{
				char32 buf[32];
				sprintf(buf, "%02d:%02d:%02d",time::Hours(),time::Minutes(),time::Seconds());
				int bg = module_arr[P3];
				int shd = module_arr[P4];
				int shd_t = module_arr[P5];
				unless(bg) bg = -1;
				unless(shd) shd_t = SHD_NORMAL;
				bit->DrawString(module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y], module_arr[P1], module_arr[P2], bg, TF_NORMAL, buf, OP_OPAQUE, shd_t, shd);
				break;
			} //end
			case MODULE_TYPE_ITEMNAME: //start
			{
				unless(active) break; //Not allowed on passive
				
				itemdata itm;
				if(g_arr[ACTIVE_SELECTED_INDEX] == -1)
					break;
				else //start find selected module
				{
					for(int q = 1; q < g_arr[NUM_ACTIVE_MODULES]; ++q)
					{
						int indx = activeModules[q];
						if(isSelectable(activeData[indx+M_TYPE]))
						{
							if(activeData[indx+P2] == g_arr[ACTIVE_SELECTED_INDEX])
							{
								switch(activeData[indx+M_TYPE])
								{
									case MODULE_TYPE_SEL_ITEM_ID:
										itm = Game->LoadItemData(activeData[indx+P1]);
										break;
									case MODULE_TYPE_SEL_ITEM_CLASS:
										int id = get_item_of_class(activeData[indx+P1]);
										if(id > -1) itm = Game->LoadItemData(id);
										break;
								}
								break;
							}
						}
					}
				} //end
				unless(itm) break; //No item loaded
				char32 buf[64];
				itm->GetName(buf);
				int bg = module_arr[P3];
				int shd = module_arr[P4];
				unless(bg) bg = -1;
				int shd_t = module_arr[P5];
				unless(shd) shd_t = SHD_NORMAL;
				int tf = module_arr[M_FLAGS1] & MASK_ITEMNM_ALIGN;
				if(module_arr[P6])
					DrawStringsBitmap(bit, module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y], module_arr[P1], module_arr[P2], bg, tf, buf, OP_OPAQUE, shd_t, shd, module_arr[P7], module_arr[P6]);
				else
					bit->DrawString(module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y], module_arr[P1], module_arr[P2], bg, tf, buf, OP_OPAQUE, shd_t, shd);
				break;
			} //end
			case MODULE_TYPE_DMTITLE: //start
			{
				char32 buf[22];
				getDMapTitle(buf);
				int bg = module_arr[P3];
				int shd = module_arr[P4];
				unless(bg) bg = -1;
				int shd_t = module_arr[P5];
				unless(shd) shd_t = SHD_NORMAL;
				int tf = module_arr[M_FLAGS1] & MASK_ITEMNM_ALIGN;
				DrawStringsBitmap(bit, module_arr[M_LAYER], module_arr[M_X], module_arr[M_Y], module_arr[P1], module_arr[P2], bg, tf, buf, OP_OPAQUE, shd_t, shd, 0, 256);
				break;
			} //end
			//case :
		}
		return EVENT_NONE;
	}
	//end Running
	//start Handler Functions
	//start Minimap
	void minimap(untyped module_arr, bitmap bit, bool active)
	{
		minimap(module_arr, bit, active, module_arr[M_X], module_arr[M_Y]);
	}
	void minimap(untyped module_arr, bitmap bit, bool active, int orig_x, int orig_y)
	{
		dmapdata dm = Game->LoadDMapData(Game->GetCurDMap());
		int curscr = Game->GetCurDMapScreen();
		bool showExplore;
		int ow = dm->Type & (11b);
		int mtile = (ow == DMAP_OVERWORLD ? module_arr[P7] : module_arr[P9]);
		int mcs = (ow == DMAP_OVERWORLD ? module_arr[P8] : module_arr[P10]);
		bool hasMap = Game->LItems[Game->GetCurLevel()] & LI_MAP;
		unless(module_arr[M_FLAGS1] & FLAG_MMP_IGNORE_DMAP_BGTILE)
		{
			if(dm->MiniMapTile[hasMap ? 1 : 0])
			{
				mtile = dm->MiniMapTile[hasMap ? 1 : 0];
				mcs = dm->MiniMapCSet[hasMap ? 1 : 0];
				//printf("without (%d,%d) - with (%d,%d)\n",dm->MiniMapTile[0],dm->MiniMapCSet[0],dm->MiniMapTile[1],dm->MiniMapCSet[1]);
			}
		}
		if(mtile) bit->DrawTile(module_arr[M_LAYER], orig_x, orig_y, mtile, 5, 3, mcs, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
		bool hasCompass = Game->LItems[Game->GetCurLevel()] & LI_COMPASS;
		bool deadCompass = Game->LItems[Game->GetCurLevel()] & ((module_arr[M_FLAGS1] & FLAG_MMP_COMP_ON_BOSS) ? LI_BOSS : LI_TRIFORCE);
		bool blinkon = g_arr[active ? ACTIVE_TIMER : PASSIVE_TIMER] & 1 << (module_arr[P6]-1);
		switch(ow)
		{
			case DMAP_BSOVERWORLD:
			case DMAP_OVERWORLD:
				showExplore = (module_arr[M_FLAGS1] & FLAG_MMP_SHOW_EXPLORED_ROOMS_OW);
				break;
			case DMAP_DUNGEON:
				showExplore = (module_arr[M_FLAGS1] & FLAG_MMP_SHOW_EXPLORED_ROOMS_DUNGEON);
				break;
			case DMAP_CAVE:
				showExplore = (module_arr[M_FLAGS1] & FLAG_MMP_SHOW_EXPLORED_ROOMS_INTERIOR);
				break;
		}
		if(ow == DMAP_OVERWORLD)
		{
			for(int q = 0; q < 128; ++q)
			{
				int x = orig_x + 9 + (4*(q%0x010));
				int y = orig_y + 8 + (4*Div(q, 0x010));
				int c = 0;
				if(hasCompass && q == dm->Compass &&
				   (blinkon || (deadCompass && !(module_arr[M_FLAGS1] & FLAG_MMP_COMPASS_BLINK_DOESNT_STOP))))
				{
					c = deadCompass ? module_arr[P5] : module_arr[P4];
				}
				else if(q == curscr)
					c = module_arr[P1];
				else if(showExplore)
				{
					mapdata m = Game->LoadMapData(Game->GetCurMap(),q);
					if(m->State[ST_VISITED])
					{
						c = module_arr[P2];
					}
				}
				
				if(c) bit->Rectangle(module_arr[M_LAYER], x, y, x+2, y+2, module_arr[P1], 1, 0, 0, 0, true, OP_OPAQUE);
			}
		}
		else
		{
			int offs = Game->DMapOffset[Game->GetCurDMap()];
			bool largeMarkers = module_arr[M_FLAGS1] & FLAG_MMP_LARGE_PLAYER_COMPASS_MARKERS;
			
			int lim = 8 - Max(offs - 8, 0);
			int low_lim = Min(offs, 0);
			
			for(int q = 0; q < 128; ++q)
			{			
				if(q % 0x10 >= lim)
					continue;
				if(q % 0x10 < low_lim)
					continue;
				
				int c = 0;
				int sm_c = 0;
				int x = orig_x + 8 + (8*(q%0x010));
				int y = orig_y + 8 + (4*Div(q, 0x010));
				
				if(hasCompass && q+offs == dm->Compass &&
				   (blinkon || (deadCompass && !(module_arr[M_FLAGS1] & FLAG_MMP_COMPASS_BLINK_DOESNT_STOP))))
				{
					c = deadCompass ? module_arr[P5] : module_arr[P4];
				}
				else if(q == curscr)
				{
					c = module_arr[P1];
				}
				
				unless(largeMarkers)
				{
					if(c)
					{
						sm_c = c;
						c = 0;
					}
				}
				unless(c)
				{
					mapdata m = Game->LoadMapData(Game->GetCurMap(),q+offs);
					if(showExplore && m->State[ST_VISITED])
					{
						c = module_arr[P2];
					}
					else if(ow != DMAP_BSOVERWORLD && hasMap && dmapinfo::VisibleOnDungeonMap(q, true))
					{
						c = module_arr[P3];
					}
				}
				if(c)
				{
					bit->Rectangle(module_arr[M_LAYER], x, y, x+6, y+2, c, 1, 0, 0, 0, true, OP_OPAQUE);
				}
				if(sm_c)
				{
					bit->Rectangle(module_arr[M_LAYER], x+2, y, x+4, y+2, sm_c, 1, 0, 0, 0, true, OP_OPAQUE);
				}
			}
		}
	} //end Minimap
	//start Life Bar
	void heartrow(bitmap bit, int layer, int x, int y, int num, int baseTile, int cset, int count, int spacing) //start
	{
		miscrow(bit, layer, x, y, num, baseTile, cset, count, spacing, CR_LIFE, HP_PER_HEART);
	} //end
	void invheartrow(bitmap bit, int layer, int x, int y, int num, int baseTile, int cset, int count, int spacing) //start
	{
		invmiscrow(bit, layer, x, y, num, baseTile, cset, count, spacing, CR_LIFE, HP_PER_HEART);
	} //end
	void heart(bitmap bit, int layer, int x, int y, int num, int baseTile, int cset) //start
	{
		crpiece(bit, layer, x, y, num, baseTile, cset, CR_LIFE, HP_PER_HEART);
	} //end
	//end Life Bar
	//start Magic Meter
	void magicrow(bitmap bit, int layer, int x, int y, int num, int baseTile, int cset, int count, int spacing) //start
	{
		miscrow(bit, layer, x, y, num, baseTile, cset, count, spacing, CR_MAGIC, MP_PER_BLOCK);
	} //end
	void invmagicrow(bitmap bit, int layer, int x, int y, int num, int baseTile, int cset, int count, int spacing) //start
	{
		invmiscrow(bit, layer, x, y, num, baseTile, cset, count, spacing, CR_MAGIC, MP_PER_BLOCK);
	} //end
	void halfmagic(bitmap bit, int layer, int x, int y, int baseTile, int cset) //start
	{
		if(Game->Generic[GEN_MAGICDRAINRATE] < 2)
		{
			minitile(bit, layer, x, y, baseTile, cset, 1);
		}
	} //end
	
	void magic(bitmap bit, int layer, int x, int y, int num, int baseTile, int cset) //start
	{
		crpiece(bit, layer, x, y, num, baseTile, cset, CR_MAGIC, MP_PER_BLOCK);
	} //end
	//end Magic Meter
	//start Misc Meter
	void miscrow(bitmap bit, int layer, int x, int y, int num, int baseTile, int cset, int count, int spacing, int cr, int contSZ) //start
	{
		if(Game->MCounter[cr] > num*contSZ)
		{
			minitile(bit, layer, x - 8 + spacing, y, baseTile, cset, 2); //Left Cap
		}
		for(int q = 0; q < count; ++q)
		{
			crpiece(bit, layer, x + (q*(8+spacing)), y, num+q, baseTile, cset, cr, contSZ);
			if(Game->MCounter[cr] == (num+q+1)*contSZ)
			{
				minitile(bit, layer, x + ((q+1)*(8+spacing)), y, baseTile, cset, 3); //Right Cap
			}
		}
		if(Game->MCounter[cr] >= (num+count)*contSZ)
		{
			minitile(bit, layer, x + (count*(8+spacing)), y, baseTile, cset, 3); //Right Cap
		}
	} //end
	void invmiscrow(bitmap bit, int layer, int x, int y, int num, int baseTile, int cset, int count, int spacing, int cr, int contSZ) //start
	{
		if(Game->MCounter[cr] > num*contSZ)
		{
			minitile(bit, layer, x + (count*(8+spacing)), y, baseTile, cset, 3); //Right Cap
		}
		for(int q = count-1; q >= 0; --q)
		{
			crpiece(bit, layer, x + (q*(8+spacing)), y, num+(count-q-1), baseTile, cset, cr, contSZ);
			if(Game->MCounter[cr] == (num+(count-q))*contSZ)
			{
				minitile(bit, layer, x + ((count-q-1)*(8+spacing)), y, baseTile, cset, 2); //Left Cap
			}
		}
		if(Game->MCounter[cr] >= (num+count)*contSZ)
		{
			minitile(bit, layer, x - 8 + spacing, y, baseTile, cset, 2); //Left Cap
		}
	} //end
	void crpiece(bitmap bit, int layer, int x, int y, int num, int baseTile, int cset, int cr, int contSZ) //start
	{
		if(Game->MCounter[cr] < (num*contSZ+1)) return;
		if(Game->Counter[cr] >= (num+1)*contSZ)
		{
			minitile(bit, layer, x, y, baseTile, cset, 0);
		}
		else if(Game->Counter[cr] < (num*contSZ+1))
		{
			minitile(bit, layer, x, y, baseTile+1, cset, 0);
		}
		else
		{
			minitile(bit, layer, x, y, baseTile+1+Div(Game->Counter[cr] % contSZ, 4), cset, (Game->Counter[cr] % contSZ) % 4);
		}
	} //end
	//end Misc Meter
	//start Counter
	bool hasInfItem(int cr) //start
	{
		switch(cr)
		{
			case CR_RUPEES:
			{
				int id = get_item_of_class(IC_WALLET);
				return (id > -1 && Game->LoadItemData(id)->Power);
			}
			case CR_BOMBS:
			{
				int id = get_item_of_class(IC_BOMBBAG);
				return (id > -1 && Game->LoadItemData(id)->Power);
			}
			case CR_SBOMBS:
			{
				int id = get_item_of_class(IC_BOMBBAG);
				if(id < 0) return false;
				itemdata dat = Game->LoadItemData(id);
				return (dat->Power && dat->Flags[0]);
			}
			case CR_ARROWS:
			{
				int id = get_item_of_class(IC_QUIVER);
				return (id > -1 && Game->LoadItemData(id)->Power);
			}
			case CR_KEYS:
			{
				int id = get_item_of_class(IC_MAGICKEY);
				if(id > -1)
				{
					itemdata dat = Game->LoadItemData(id);
					return (dat->Flags[0] ? dat->Power >= Game->GetCurLevel() : dat->Power == Game->GetCurLevel());
				}
				return false;
			}
		}
		return false;
	} //end
	int getCost(itemdata id) //start
	{
		switch(id->Type)
		{
			case IC_ARROW: return Game->FFRules[qr_TRUEARROWS] ? CR_ARROWS : CR_RUPEES;
			case IC_BOMB: return CR_BOMBS;
			case IC_SBOMB: return CR_SBOMBS;
			default: return id->Cost ? id->CostCounter : -1;
		}
	} //end
	//returns width in pixels
	int counter(untyped arr, bitmap bit, int layer, int x, int y)
	{
		//FORMAT: {META..., FONT, CNTR, INFITEM, INFCHAR, MINDIG, TXTCOL, BGCOL, SHADCOL}
		int val = 0;
		bool infinite = hasItem(arr[P3]);
		unless(infinite)
		{
			if(arr[M_FLAGS1] & FLAG_CNTR_SPECIAL) //start Special types
			{
				switch(arr[P2])
				{
					case CNTR_ANYKEY:
						val = Game->Counter[CR_KEYS];
						//fallthrough
					case CNTR_LKEY:
						val += Game->LKeys[Game->GetCurLevel()];
						if(hasInfItem(CR_KEYS)) infinite = true;
						break;
					case CNTR_ABTN:
						unless(Hero->ItemA > 0) return 0;
						itemdata id = Game->LoadItemData(Hero->ItemA);
						int cr = getCost(id);
						if(cr > CR_CUSTOM25 || cr < 0) return 0;
						if(hasInfItem(cr)) infinite = true;
						val = Game->Counter[cr];
						break;
					case CNTR_BBTN:
						unless(Hero->ItemB > 0) return 0;
						itemdata id = Game->LoadItemData(Hero->ItemB);
						int cr = getCost(id);
						if(cr > CR_CUSTOM25 || cr < 0) return 0;
						if(hasInfItem(cr)) infinite = true;
						val = Game->Counter[cr];
						break;
				}
			} //end
			else
			{
				val = Game->Counter[arr[P2]];
				if(hasInfItem(arr[P2])) infinite = true;
			}
			unless(val || infinite || arr[P5]) return 0; //no min digits, and no value
		}
		char32 buf[6];
		if(infinite)
		{
			unless(arr[P4]) return 0; //No infinite char
			buf[0] = arr[P4]; //Infinite char
		}
		else
		{
			char32 format[16] = "%i";
			if(arr[P5])
				sprintf(format, "%%0%ii", arr[P5]); //Puts '%0ni' in buffer, with n = min digits
			sprintf(buf, format, val);
			if(arr[M_FLAGS1] & FLAG_CNTR_SPACE_INSTEAD_LEAD_ZERO) //start Trim lead 0s
			{
				for(int q = 0; q < 6; ++q)
				{
					if(buf[q] == '0')
						buf[q] = ' ';
					else
					{
						unless(buf[q])
							buf[q-1] = '0'; //Restore last '0' if it was eaten
						break;
					}
				}
			} //end
		}
		//buf now contains the proper counter value
		int bg = arr[P7];
		int shd = arr[P8];
		int shd_t = arr[P9];
		unless(bg) bg = -1;
		unless(shd) shd_t = SHD_NORMAL;
		int wid = Text->StringWidth(buf, arr[P1]) + (shd_t?1:0);
		
		if(arr[P6])
			bit->DrawString(layer, x, y, arr[P1], arr[P6], bg, arr[M_FLAGS1] & MASK_CNTR_ALIGN, buf, OP_OPAQUE, arr[P9], shd);
		return wid + ((arr[P9])?1:0);
	}
	//end Counter
	//end Handler Functions
	//start Misc
	//start Selector
	void PrepareSelector(int layer, int x, int y, int wid, int hei, bool active, int selection_style, int val1, int val2)
	{
		g_arr[PREPARED_SELECTOR_DATA_START+0] = layer;
		g_arr[PREPARED_SELECTOR_DATA_START+1] = x;
		g_arr[PREPARED_SELECTOR_DATA_START+2] = y;
		g_arr[PREPARED_SELECTOR_DATA_START+3] = wid;
		g_arr[PREPARED_SELECTOR_DATA_START+4] = hei;
		g_arr[PREPARED_SELECTOR_DATA_START+5] = active;
		g_arr[PREPARED_SELECTOR_DATA_START+6] = selection_style;
		g_arr[PREPARED_SELECTOR_DATA_START+7] = val1;
		g_arr[PREPARED_SELECTOR_DATA_START+8] = val2;
	}
	void runPreparedSelector(bool active)
	{
		if(g_arr[PREPARED_SELECTOR_DATA_START+0] < 0 || active != g_arr[PREPARED_SELECTOR_DATA_START+5]) return;
		g_arr[PREPARED_SELECTOR_DATA_START+0] = 7; //Force layer to top, to draw over everything else.
		DrawSelector(g_arr[PREPARED_SELECTOR_DATA_START+0],g_arr[PREPARED_SELECTOR_DATA_START+1],g_arr[PREPARED_SELECTOR_DATA_START+2],
		             g_arr[PREPARED_SELECTOR_DATA_START+3],g_arr[PREPARED_SELECTOR_DATA_START+4],g_arr[PREPARED_SELECTOR_DATA_START+5],
		             false,                                g_arr[PREPARED_SELECTOR_DATA_START+6],g_arr[PREPARED_SELECTOR_DATA_START+7],
					 g_arr[PREPARED_SELECTOR_DATA_START+8]);
		clearPreparedSelector();
	}
	void clearPreparedSelector()
	{
		memset(g_arr, PREPARED_SELECTOR_DATA_START, -1, PREPARED_SELECTOR_DATA_END-PREPARED_SELECTOR_DATA_START);
	}
	void DrawSelector(int layer, int x, int y, int wid, int hei, bool active)
	{
		DrawSelector(layer, x, y, wid, hei, active, true, activeData[A_STTNG_SELECTOR_TYPE], activeData[A_STTNG_SELECTOR_VALUE], activeData[A_STTNG_SELECTOR_VALUE2]);
	}
	void DrawSelector(int layer, int x, int y, int wid, int hei, bool active, bool onlyOnce)
	{
		DrawSelector(layer, x, y, wid, hei, active, onlyOnce, activeData[A_STTNG_SELECTOR_TYPE], activeData[A_STTNG_SELECTOR_VALUE], activeData[A_STTNG_SELECTOR_VALUE2]);
	}
	void DrawSelector(int layer, int x, int y, int wid, int hei, bool active, bool onlyOnce, int selection_style, int val1)
	{
		DrawSelector(layer, x, y, wid, hei, active, onlyOnce, selection_style, val1, 0);
	}
	void DrawSelector(int layer, int x, int y, int wid, int hei, bool active, bool onlyOnce, int selection_style, int val1, int val2)
	{
		if(onlyOnce)
		{
			PrepareSelector(layer, x, y, wid, hei, active, selection_style, val1, val2);
			return;
		}
		bitmap bit = getSubscreenBitmap(active);
		switch(selection_style)
		{
			case SEL_TILE:
			{
				bit->DrawTile(layer, x, y, val1, Ceiling(wid/16), Ceiling(hei/16), val2, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
				return;
			}
			case SEL_COMBO:
			{
				bit->DrawCombo(layer, x, y, val1, Ceiling(wid/16), Ceiling(hei/16), val2, -1, -1, 0, 0, 0, 0, 0, true, OP_OPAQUE);
				return;
			}
			case SEL_RECTANGLE:
			{
				bit->Rectangle(layer, x, y, x+wid, y+hei, val1, -1, 0, 0, 0, false, OP_OPAQUE);
				return;
			}
			case SEL_ITEM:
			{
				itemdata id = Game->LoadItemData(val1);
				int frm = Div(g_arr[ACTIVE_TIMER] % (Max(1,id->ASpeed*id->AFrames)),Max(1,id->ASpeed));
				bit->FastTile(layer, x, y, id->Tile + frm, id->CSet, OP_OPAQUE);
				return;
			}
		}
	} //end Selector
	void minitile(bitmap bit, int layer, int x, int y, int tile, int cset, int corner) //start
	{
		unless(<bitmap>(g_arr[MINITILE_BITMAP])->isValid())
		{
			<bitmap>(g_arr[MINITILE_BITMAP])->Free();
			g_arr[MINITILE_BITMAP] = Game->CreateBitmap(16,16);
		}
		<bitmap>(g_arr[MINITILE_BITMAP])->Clear(0);
		<bitmap>(g_arr[MINITILE_BITMAP])->FastTile(0, 0, 0, tile, cset, OP_OPAQUE);
		<bitmap>(g_arr[MINITILE_BITMAP])->Blit(layer, bit, (corner&01b)?8:0, (corner&10b)?8:0, 8, 8, x, y, 8, 8, 0, 0, 0, 0, 0, true);
	} //end
	bool hasItem(int itmid) //start
	{
		if(itmid < MIN_ITEMDATA || itmid > MAX_ITEMDATA) return false;
		unless(Hero->Item[itmid] && !(Game->DisableItem[itmid]))
			return false;
		if(Game->FFRules[qr_NEVERDISABLEAMMOONSUBSCREEN])
			return true;
		itemdata id = Game->LoadItemData(itmid);
		if(id->CostCounter > -1)
		{
			if(Game->Counter[id->CostCounter] < id->Cost)
				return false;
		}
		switch(id->Type)
		{
			case IC_BOMB:
				return Game->Counter[CR_BOMBS] > 0;
			case IC_SBOMB:
				return Game->Counter[CR_SBOMBS] > 0;
			case IC_ARROW:
				return Game->Counter[CR_ARROWS] > 0;
		}
		return true;
	} //end
	void getDMapTitle(char32 buf) //start
	{
		Game->GetDMapTitle(Game->GetCurDMap(), buf);
		for(int q = 21; q > 10; --q)
			buf[q] = buf[q-1];
		buf[10] = '\n';
	} //end
	bitmap getSubscreenBitmap(bool active) //start
	{
		if(active)
		{
			DEFINE H = 168+56, W = 256;
			unless((<bitmap>g_arr[ACTIVE_BITMAP])->isAllocated()) g_arr[ACTIVE_BITMAP] = Game->AllocateBitmap();
			unless((<bitmap>g_arr[ACTIVE_BITMAP])->isValid()) generate((<bitmap>g_arr[ACTIVE_BITMAP]), W, H);
			return (<bitmap>g_arr[ACTIVE_BITMAP]);
		}
		else
		{
			DEFINE H = 56, W = 256;
			unless((<bitmap>g_arr[PASSIVE_BITMAP])->isAllocated()) g_arr[PASSIVE_BITMAP] = Game->AllocateBitmap();
			unless((<bitmap>g_arr[PASSIVE_BITMAP])->isValid()) generate((<bitmap>g_arr[PASSIVE_BITMAP]), W, H);
			return (<bitmap>g_arr[PASSIVE_BITMAP]);
		}
	} //end
	void clearActive1frame() //start
	{
		getSubscreenBitmap(true)->Clear(7);
		getSubscreenBitmap(false)->Clear(7);
		g_arr[ACTIVE_1FRAME_FLAGS_1] = 0;
		g_arr[SHARED_1FRAME_FLAGS_1] = 0;
		if(g_arr[LAST_SELECTED_INDEX] != g_arr[ACTIVE_SELECTED_INDEX])
		{
			g_arr[INDEX_SELECTION_COOLDOWN] = 2;
		}
		else if(g_arr[INDEX_SELECTION_COOLDOWN])
			--g_arr[INDEX_SELECTION_COOLDOWN];
		g_arr[LAST_SELECTED_INDEX] = g_arr[ACTIVE_SELECTED_INDEX];
	} //end
	void clearPassive1frame() //start
	{
		getSubscreenBitmap(false)->Clear(7);
		g_arr[PASSIVE_1FRAME_FLAGS_1] = 0;
		g_arr[SHARED_1FRAME_FLAGS_1] = 0;
	} //end
	//end
	//start Button Item stuff
	int get_btn_itm(int btn) //start Calculate the item on a button
	{
		int val = btn_data[BTNITMS+btn];
		if(val >= 0)
		{
			return val;
		}
		else if(val < -1000)
		{
			return get_item_of_class(-val -1000);
		}
		else return -1;
	} //end
	void set_btn_pos(int btn, int pos) //start Sets the pos of a button
	{
		int oldpos = btn_data[BTNPOS+btn];
		btn_data[BTNPOS+btn] = pos;
		if(pos < 0) return;
		for(int q = 0; q < CB_MAX; ++q) //start
		{
			switch(q) //start Filter out unused buttons
			{
				case CB_A: case CB_B: case CB_L: case CB_R: case CB_EX1: case CB_EX2: case CB_EX3: case CB_EX4:
				{
					unless(activeData[A_STTNG_BUTTON_ITEM_ENABLED_BITS] & (1<<q))
						continue;
				}
				default: continue;
			} //end
			if(btn_data[BTNPOS+q] == pos)
			{
				btn_data[BTNPOS+q] = oldpos;
				oldpos = -1;
			}
		} //end
	} //end
	void equp_btn_itm(int btn, int id) //start Sets the item (ID) of a button
	{
		btn_data[BTNITMS+btn] = id;
	} //end
	void equp_btn_itmclass(int btn, int class) //start Sets the item (class) of a button
	{
		btn_data[BTNITMS+btn] = -class -1000;
	} //end
	void dequp_btn(int btn) //start Sets a button to be empty
	{
		btn_data[BTNITMS+btn] = -1;
		btn_data[BTNPOS+btn] = -1;
	} //end
	void handle_buttons() //start Handle button inputs
	{
		bool b_assigned;
		for(int q = 0; q < CB_MAX; ++q) //start
		{
			switch(q) //start Handle QuickSwap
			{
				case CB_L:
					unless(Game->FFRules[qr_NO_L_R_BUTTON_INVENTORY_SWAP])
					{
						if(activeData[A_STTNG_BUTTON_ITEM_ASSIGNABLE_BITS] & (1<<CB_B))
							shuffle_button(CB_B, DIR_LEFT, false);
						continue;
					}
					break;
				case CB_R:
					unless(Game->FFRules[qr_NO_L_R_BUTTON_INVENTORY_SWAP])
					{
						if(activeData[A_STTNG_BUTTON_ITEM_ASSIGNABLE_BITS] & (1<<CB_B))
							shuffle_button(CB_B, DIR_RIGHT, false);
						continue;
					}
					break;
				case CB_EX3:
					if(Game->FFRules[qr_USE_EX1_EX2_INVENTORYSWAP])
					{
						if(activeData[A_STTNG_BUTTON_ITEM_ASSIGNABLE_BITS] & (1<<CB_A))
							shuffle_button(CB_A, DIR_LEFT, false);
						continue;
					}
					break;
				case CB_EX4:
					if(Game->FFRules[qr_USE_EX1_EX2_INVENTORYSWAP])
					{
						if(activeData[A_STTNG_BUTTON_ITEM_ASSIGNABLE_BITS] & (1<<CB_A))
							shuffle_button(CB_A, DIR_RIGHT, false);
						continue;
					}
					break;
			} //end
			switch(q) //start Filter out unused buttons
			{
				case CB_A: case CB_B: case CB_L: case CB_R: case CB_EX1: case CB_EX2: case CB_EX3: case CB_EX4:
				{
					unless(activeData[A_STTNG_BUTTON_ITEM_ENABLED_BITS] & (1<<q))
						continue;
					break;
				}
				default: continue;
			} //end
			unless(hasItem(get_btn_itm(q)))
				shuffle_button(q, DIR_RIGHT, true); //Check if the item is owned, and if not, shuffle it
			int itm = get_btn_itm(q);
			if(q == CB_A)
			{
				Hero->ItemA = itm;
				continue;
			}
			if(b_assigned) continue;
			// if(q == CB_B) { Hero->ItemB = itm; continue; }
			if(Input->Button[q])
			{
				Hero->ItemB = itm;
				unless(q == CB_B)
				{
					Input->Button[CB_B] = true;
					Input->Press[CB_B] = Input->Press[q];
					Input->Press[q] = false;
					Input->Button[q] = false;
				}
				b_assigned = true;
			}
		} //end
	} //end
	void shuffle_button(int btn, int dir, bool forceNew) //start Move a button to the next available position
	{
		int pos = btn_data[BTNPOS+btn];
		unless(pos) return;
		bool visited[MAX_INT];
		visited[pos] = true;
		for(int q = 1; q < g_arr[NUM_ACTIVE_MODULES]; ++q)
		{
			int indx = activeModules[q];
			if(isSelectable(activeData[indx+M_TYPE]))
			{
				if(activeData[indx+P2] == pos)
				{
					int try_itm = -1;
					int try_class = -1;
					pos = activeData[indx+P2+dir];
					q = 1;
					if(activeData[indx+M_TYPE] == MODULE_TYPE_SEL_ITEM_ID)
						try_itm = activeData[indx+P1];
					else if(activeData[indx+M_TYPE] == MODULE_TYPE_SEL_ITEM_CLASS)
					{
						try_class = activeData[indx+P1];
						try_itm = get_item_of_class(try_class);
					}
					if(try_itm > -1 && hasItem(try_itm))
					{
						if(try_class > -1)
							equp_btn_itmclass(btn, try_class);
						else equp_btn_itm(btn, try_itm);
						set_btn_pos(btn, pos);
						return;
					}
					if(visited[pos])
					{
						if(forceNew)
							dequp_btn(btn);
						return;
					}
					visited[pos] = true;
				}
			}
		}
	} //end
	void init_buttons() //start
	{
		btn_data[BTNITM_A] = Hero->ItemA;
		btn_data[BTNITM_B] = Hero->ItemB;
		for(int q = 0; q < CB_MAX; ++q)
		{
			btn_data[BTNPOS+q] = -1;
		}
	} //end
	//end Button Item stuff
	//start getters/setters
	int getModX(int mod_indx, bool active)
	{
		return active ? activeData[activeModules[mod_indx]+M_X] : passiveData[passiveModules[mod_indx]+M_X];
	}
	int getModY(int mod_indx, bool active)
	{
		return active ? activeData[activeModules[mod_indx]+M_Y] : passiveData[passiveModules[mod_indx]+M_Y];
	}
	void setModX(int mod_indx, bool active, int x)
	{
		(active ? (activeData[activeModules[mod_indx]+M_X]=x) : (passiveData[passiveModules[mod_indx]+M_X]=x));
	}
	void setModY(int mod_indx, bool active, int y)
	{
		(active ? (activeData[activeModules[mod_indx]+M_Y]=y) : (passiveData[passiveModules[mod_indx]+M_Y]=y));
	}
	int incModX(int mod_indx, bool active, int x_off)
	{
		if(active)
		{
			activeData[activeModules[mod_indx]+M_X]+=x_off;
			return activeData[activeModules[mod_indx]+M_X];
		}
		else
		{
			passiveData[passiveModules[mod_indx]+M_X]+=x_off;
			return passiveData[passiveModules[mod_indx]+M_X];
		}
	}
	int incModY(int mod_indx, bool active, int y_off)
	{
		if(active)
		{
			activeData[activeModules[mod_indx]+M_Y]+=y_off;
			return activeData[activeModules[mod_indx]+M_Y];
		}
		else
		{
			passiveData[passiveModules[mod_indx]+M_Y]+=y_off;
			return passiveData[passiveModules[mod_indx]+M_Y];
		}
	}
	//end
	
	using namespace Venrob::Subscreen::Internal;
	namespace Internal //start
	{
		//start Loggers
		void traceArr(untyped arr)
		{
			traceArr(arr, 0, -1);
		}
		void traceArr(untyped arr, int pos)
		{
			traceArr(arr, pos, -1);
		}
		void traceArr(untyped arr, int pos, int len)
		{
			DEFINE end = ((len < 0) ? SizeOfArray(arr) : Min(SizeOfArray(arr), pos + len));
			unless(pos<end) return;
			for(int q = pos; q < end; ++q)
			{
				printf("%d: %d\n", q, arr[q]);
			}
			TraceNL();
		}
		
		void error(char32 msg)
		{
			printf("[ERROR] [VenrobSubscreen.zh] %s\n", msg);
		}
		
		void error(char32 msg, untyped arg1)
		{
			char32 buf[2048];
			sprintf(buf, "[ERROR] [VenrobSubscreen.zh] %s\n", msg);
			printf(buf, arg1);
		}
		
		void error(char32 msg, untyped arg1, untyped arg2)
		{
			char32 buf[2048];
			sprintf(buf, "[ERROR] [VenrobSubscreen.zh] %s\n", msg);
			printf(buf, arg1, arg2);
		}
		
		void error(char32 msg, untyped arg1, untyped arg2, untyped arg3)
		{
			char32 buf[2048];
			sprintf(buf, "[ERROR] [VenrobSubscreen.zh] %s\n", msg);
			printf(buf, arg1, arg2, arg3);
		}
		
		void debug(char32 msg)
		{
			printf("[DEBUG] [VenrobSubscreen.zh] %s\n", msg);
		}
		
		void debug(char32 msg, untyped arg1)
		{
			char32 buf[2048];
			sprintf(buf, "[DEBUG] [VenrobSubscreen.zh] %s\n", msg);
			printf(buf, arg1);
		}
		
		void debug(char32 msg, untyped arg1, untyped arg2)
		{
			char32 buf[2048];
			sprintf(buf, "[DEBUG] [VenrobSubscreen.zh] %s\n", msg);
			printf(buf, arg1, arg2);
		} //end Loggers
		
		bool PressCheck(int cb)
		{
			if(Input->Press[cb] || (Input->Button[cb] && !g_arr[INPUT_TIMERS+cb]))
			{
				g_arr[INPUT_TIMERS+cb] = 0;
				return true;
			}
			return false;
		}
		
		void PressClear(int cb)
		{
			g_arr[INPUT_TIMERS+cb] = 1;
		}
		
		void killBtn(int cb)
		{
			killBtn(cb, false);
		}
		void killBtn(int cb, bool pushtimer)
		{
			Input->Press[cb] = false;
			Input->Button[cb] = false;
			if(pushtimer) g_arr[INPUT_TIMERS+cb] = 1;
		}
		
		void KillButtons()
		{
			KillButtons(false);
		}
		void KillButtons(bool pushtimers)
		{
			for(int q = 0; q < 18; ++q)
			{
				killBtn(q);
				if(pushtimers) PressClear(q);
			}
		}
		
		int get_item_of_class(int ic)
		{
			get_item_of_class(ic, false);
		}
		int get_item_of_class(int ic, bool noRequire)
		{
			int highestLevel = -1;
			int highestID = -1;
			for(int q = MIN_ITEMDATA; q <= MAX_ITEMDATA; ++q)
			{
				itemdata id = Game->LoadItemData(q);
				if(noRequire || hasItem(q))
				{
					if(id->Type == ic)
					{
						if(id->Level > highestLevel)
						{
							highestLevel = id->Level;
							highestID = q;
						}
					}
				}
			}
			return highestID;
		}
		
		bool isSelectable(int type)
		{
			switch(type)
			{
				case MODULE_TYPE_SEL_ITEM_ID:
				case MODULE_TYPE_SEL_ITEM_CLASS:
				{
					return true;
				}
				
				default:
					return false;
			}
		}
		
		bool canSelect(untyped module_arr) //start
		{
			switch(module_arr[M_TYPE])
			{
				case MODULE_TYPE_SEL_ITEM_ID:
				{
					int itmid = module_arr[P1];
					return (itmid >= 0 && hasItem(itmid));
				}
				case MODULE_TYPE_SEL_ITEM_CLASS:
				{
					int itmid = get_item_of_class(module_arr[P1]);
					return (itmid >= 0 && hasItem(itmid));
				}
				
				default:
					return isSelectable(module_arr[M_TYPE]);
			}
		} //end
		bool canSelect(untyped module_arr, int offs) //start
		{
			switch(module_arr[offs+M_TYPE])
			{
				case MODULE_TYPE_SEL_ITEM_ID:
				{
					int itmid = module_arr[offs+P1];
					return (itmid >= 0 && hasItem(itmid));
				}
				case MODULE_TYPE_SEL_ITEM_CLASS:
				{
					int itmid = get_item_of_class(module_arr[offs+P1]);
					return (itmid >= 0 && hasItem(itmid));
				}
				
				default:
					return isSelectable(module_arr[offs+M_TYPE]);
			}
		} //end
		
	} //end Internal
}